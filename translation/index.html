<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>다크 모드 가이드</title>
<link rel="preconnect" href="https://fonts.gstatic.com">
<link rel="stylesheet" type="text/css" href="../css/transl.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/styles/dracula.min.css">
</head>
<body>
<div class="header">
    <h1>A Complete Guide to Dark Mode on the Web</h1>
    <dl class="info_article">
        <div>
            <dt>Author</dt>
            <dd><a href="https://css-tricks.com/author/mohamedadhuham/" target="_blank">Adhuham</a></dd>
        </div>
        <div>
            <dt>Last Updated</dt>
            <dd>Mar 11, 2021</dd>
        </div>
        <div>
            <dt>Translator/Date</dt>
            <dd>rocksujin(April 20, 2021)</dd>
        </div>
    </dl>
</div>
<div class="content_wrap">
    <div class="orig_link">
        <strong>원본: </strong>
        <a href="https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/" target="_blank">https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/</a>
    </div>
    <div class="content">
        <div class="intro">
            <p>최근 들어 다크 모드가 엄청난 관심을 받고 있다. 애플은 iOS랑 MacOS 운영체제에 다크 모드를 추가했고, 윈도우와 구글도 애플처럼 다크 모드를 추가했다.</p>
            <img width="1000" src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/06/OyfkbMzf.png?fit=1024%2C476&amp;ssl=1" alt="" >
            <span class="img_info">DuckDuckGo’s 라이트 모드와 다크 모드</span>
            <p>자 그럼 웹사이트의 다크 모드에 대해 알아보자. 다크 모드 디자인을 구현하기 위한 다양한 옵션과 접근 방식, 그리고 그에 수반되는 기술적 고려 사항을 살펴보고, 그 과정에서 몇 가지 디자인 팁을 함께 다루어보자.</p>
            <div class="toc">
                <strong>Table of Contents</strong>
                <ol>
                    <li>Part 1: <a href="#part1">테마 변경하기(Toggling Themes)</a></li>
                    <li>Part 2: <a href="#part2">운영체제 단계에서 다크 모드</a></li>
                    <li>Part 3: <a href="#part3">사용자 설정 저장</a></li>
                    <li>Part 4: <a href="#part4">UA 스타일 다루기</a></li>
                    <li>Part 5: <a href="#part5">응용하기</a></li>
                    <li>Part 6: <a href="#part6">디자인 고려사항 </a></li>
                    <li>Part 7: <a href="#part7">다크 모드 활용 예시</a></li>
                </ol>
            </div>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part1">
            <h2>테마 변경하기(Toggling Themes)</h2>
            <p>일반적으로 사이트는 이미 라이트(기본) 테마가 있고, 우리는 그것보다 상대적으로 어두운 테마를 만들려고 한다. 혹은 처음부터 라이트 테마 다크 테마 둘 다 만들 수도 있다.
            하나의 테마는 사용자가 처음 방문할 때 보는 기본값으로 되어야 하는데 그게 보통 라이트 모드다. (사용자의 브라우저가 대신 선택할 수도 있다.) 다른 테마로 전환하는 스위치를 추가하는 방법도 있다.
         (자동으로 전환되게 할 수도 있다. 이따가 더 살펴보자) - 말 그대로 사용자가 버튼을 클릭하면 색상 테마가 변경되는 방법이다.</p>
            <p>색상 테마 변경을 위한 몇 가지 방식들이 있다.</p>
            <ul class="sample">
                <li>
                    <details>
                        <summary><h4>Using a Body Class</h4></summary>
                        <p>페이지 어느 곳이든 스타일을 변경하기 위한 클래스를 교체할 수 있다.</p>
                        <pre>
                            <code>
&lt;body class="dark-theme || light-theme"&gt;
                            </code>
                        </pre>

                        <p>클래스를 변경하는 토글 버튼 스크립트 예시:</p>
                        <pre class="js">
                            <code>
// Select the button
const btn = document.querySelector('.btn-toggle');

// Listen for a click on the button
btn.addEventListener('click', function() {
// Then toggle (add/remove) the .dark-theme class to the body
document.body.classList.toggle('dark-theme');
})
                            </code>
                        </pre>

                        <p>사용하는 방법은 다음과 같다.</p>
                        <pre>
                            <code>
&lt;body&gt;
  &lt;button class="btn-toggle"&gt;Toggle Dark Mode&lt;/button&gt;
  &lt;h1&gt;Hey there! This is just a title&lt;/h2&gt;
  &lt;p&gt;I am just a boring text, existing here solely for the purpose of this demo&lt;/p&gt;
  &lt;p&gt;And I am just another one like the one above me, because two is better than having only one&lt;/p&gt;
  &lt;a href="#"&gt;I am a link, don't click me!&lt;/a&gt;
&lt;/body&gt;
                            </code>
                        </pre>

                        <p>이 방식의 아이디어는 평소처럼 스타일을 지정하고 그것을 "Default" 모드라 부르고, <code class="highlight">&lt;body&gt;</code> 태그에 "Dark" 모드로 쓸 클래스를 넣어 색상 스타일을 세팅한다.</p>
                        <p>기본이 밝은 색상라 치고, 모든 "밝은(라이트)" 스타일은 평소처럼 css를 만든다. 지정한 HTML의 바디와 링크에 글로벌하게 스타일을 적용한다.</p>
                        <pre class="css">
                            <code>
body {
  color: #222;
  background: #fff;
}
a {
  color: #0033cc;
}
                            </code>
                        </pre>
                        <p>밝은 배경(<code class="highlight">#fff</code>)에 다크 텍스트(<code class="highlight">#222</code>)와 다크 링크(<code class="highlight">#003322</code>)를 만들었다. 그럼 "Default"테마가 탄탄하게 시작된다.</p>
                        <p>이제 이 속성값을 재정의 해보자. 이번에는 다른 body에 클래스를 설정한다.</p>
                        <pre class="css">
                            <code>
body {
  color: #222;
  background: #fff;
}
a {
  color: #0033cc;
}
 
/* Dark Mode styles */
body.dark-theme {
  color: #eee;
  background: #121212;
}
body.dark-theme a {
  color: #809fff;
}
                            </code>
                        </pre>
                        <p>다크 테마 스타일들은 우리가 <code class="highlight">&lt;body&gt;</code> 태그에 적용한 같은 부모 클래스의 후손이 된다. (<code class="highlight">.dark-theme</code>)</p>
                        <p>body 클래스를 다크 모드로 전환하려면 어떻게 해야할까? JavaScript를 사용할 수 있다. button 클래스를 (<code class="highlight">.btn-toggle</code>) 고르고 클릭시 리스너를 추가하고난 뒤에
                        body의 다크 모드 클래스(<code class="highlight">.dark-theme</code>)를 추가한다. 이는 종속성과 특이성 덕분에 "밝은" 색상들을 효과적으로 재정의한다.</p>

                        <p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="adhuham" data-slug-hash="dyodgPj" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Method 1 - Class Swapping">
                          <span>See the Pen <a href="https://codepen.io/adhuham/pen/dyodgPj">
                          Method 1 - Class Swapping</a> by Mohamed Adhuham (<a href="https://codepen.io/adhuham">@adhuham</a>)
                          on <a href="https://codepen.io">CodePen</a>.</span>
                        </p>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><h4>Using Separate Stylesheets</h4></summary>
                        <p>모든 스타일을 하나의 stylesheet에 넣기보다는, 테마별로 stylesheet를 전환할 수 있다. 전체 stylesheetㄹㄹ 가지고 있다고 가정하고 간다.</p>
                        <p>예를들어, 기본 라이트  테마는 <code class="highlight">light-theme.css</code>:</p>
                        <pre class="css">
                            <code>
/* light-theme.css */
 
body {
color: #222;
background: #fff;
}
a {
color: #0033cc;
}
                            </code>
                        </pre>
                        <p>다크 테마 스타일은 만들어서 별도의 다크 테마 stylesheet <code class="highlight">dark-theme.css</code>에 저장한다.</p>
                        <pre class="css">
                            <code>
/* dark-theme.css */
 
body {
  color: #eee;
  background: #121212;
}
body a {
  color: #809fff;
}
                            </code>
                        </pre>
                        <p>이 두개의 분리된 stylesheet를 html <code class="highlight">&lt;head&gt;</code>로 연결한다.</p>
                        <pre class="html">
                            <code>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  <!-- Light theme stylesheet -->
  &lt;link href="light-theme.css" rel="stylesheet" id="theme-link"&gt;
&lt;/head&gt;
 
<!-- etc. -->
 
&lt;/html&gt;
                            </code>
                        </pre>
                        <p>JavaScript로 선택할 수 있는 <code class="highlight">#theme-link</code> 사용하여 라이트 테마와 다크 테마 사이를 전환할 수 있다. 이번에만 클래스대신 파일을 전환한다.</p>
                        <pre class="js">
                            <code>
// Select the button
const btn = document.querySelector(".btn-toggle");
// Select the stylesheet &lt;link&gt;
const theme = document.querySelector("#theme-link");

// Listen for a click on the button
btn.addEventListener("click", function() {
  // If the current URL contains "ligh-theme.css"
  if (theme.getAttribute("href") == "light-theme.css") {
    // ... then switch it to "dark-theme.css"
    theme.href = "dark-theme.css";
  // Otherwise...
  } else {
    // ... switch it to "light-theme.css"
    theme.href = "light-theme.css";
  }
});
                            </code>
                        </pre>
                        <a href="https://codepen.io/adhuham/project/full/AqjdGV">View Demo</a>
                    </details>

                </li>
                <li>
                    <details>
                        <summary><h4>Using Custom Properties</h4></summary>
                        <p>CSS 커스텀의 강력한 기능을 활용하여 다크 테마를 만들 수 있다. 각 테마에 별도의 스타일 규칙을 주지 않아도 되므로, 훨씬 빠르게 스타일을 작성하고 필요한경우 테마를 더 쉽게 바꿀 수 있다.</p>
                        <br>
                        <p>여전히 바디의 클래스를 교체하고 해당 클래스를 사용하여 다시 사용자 지정 세팅을 할 수도 있다:</p>
                        <pre class="js">
                            <code>
// Select the button
const btn = document.querySelector(".btn-toggle");
 
// Listen for a click on the button
btn.addEventListener("click", function() {
  // Then toggle (add/remove) the .dark-theme class to the body
  document.body.classList.toggle("dark-theme");
});
                            </code>
                        </pre>
                        <p>우선, 기본 밝은 색상을 사용자 지정 속성으로 정의를 한다:</p>
                        <pre class="css">
                            <code>
body {
  --text-color: #222;
  --bkg-color: #fff;
  --anchor-color: #0033cc;
}
                            </code>
                        </pre>
                        <p>그리고 방금 했던것 처럼 바디의 <code class="highlight">.dark-theme</code> 클래스 아래로 속성들을 재지정 할 수 있다.</p>
                        <pre class="css">
                            <code>
body.dark-theme {
  --text-color: #eee;
  --bkg-color: #121212;
  --anchor-color: #809fff;
}
                            </code>
                        </pre>
                        <p>다음은 사용자 지정 속성을 사용하는 바디 및 링크 요소에 대한 룰셋이다.</p>
                        <pre class="css">
                            <code>
body {
  color: var(--text-color);
  background: var(--bkg-color);
}
a {
  color: var(--anchor-color);
}
                            </code>
                        </pre>
                    </details>
                </li>
                <li>
                    <details>
                        <summary><h4>Using Server-Side Scripts</h4></summary>
                        <p>이미 PHP 같은 server-side 언어로 작업하고 있다면 JavaScript 대신 사용할 수 있다. 마크업에 직접 작업하는 것을 선호한다면 이는 휼륭한 접근 방식이다.</p>
                        <pre class="php">
                            <code>
&lt;?php
$themeClass = '';
if (isset($_GET['theme']) && $_GET['theme'] == 'dark') {
  $themeClass = 'dark-theme';
}
 
$themeToggle = ($themeClass == 'dark-theme') ? 'light' : 'dark';
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;!-- etc. --&gt;
&lt;body class="&lt;?php echo $themeClass; ?&gt;"&gt;
  &lt;a href="?theme=&lt;?php echo $themeToggle; ?&gt;"&gt;Toggle Dark Mode&lt;/a&gt;
  &lt;!-- etc. --&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                        </pre>
                        <p>사용자가 <code class="highlight">GET</code> 또는 <code class="highlight">POST</code> 리퀘스트를 보낼 수 있도록 한 뒤, 페이지가 새로고침 될 때 코드가 적절한 바디 클래스에 적용되도록 한다.
                        여기서는 이 데모를 위해 <code class="highlight">GET</code> (URL params)을 사용하고 있다.</p>
                        <p>그리고 두번째 방법에서 했던 것 처럼 스타일시트를 바꿀 수 있다.</p>
                        <pre class="php">
                            <code>
&lt;?php
$themeStyleSheet = 'light-theme.css';
if (isset($_GET['theme']) && $_GET['theme'] == 'dark') {
  $themeStyleSheet = 'dark-theme.css';
}
 
$themeToggle = ($themeStyleSheet == 'dark-theme.css') ? 'light' : 'dark';
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head>
  &lt;!-- etc. --&gt;
  &lt;link href="&lt;?php echo $themeStyleSheet; ?&gt;" rel="stylesheet"&gt;
&lt;/head&gt;
 
&lt;body&gt;
  &lt;a href="?theme=&lt;?php echo $themeToggle; ?&gt;"&gt;Toggle Dark Mode&lt;/a&gt;
  &lt;!-- etc. --&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                        </pre>
                        <p>이 방법에는 명백한 단점이 있다: 토글하려면 페이지를 새로고침 해야한다. 근데 나중에 보겠지만, 이런 server-side 솔루션은 페이지 리로드 시 사용자의 테마를 유지하기에 유용하다.</p>
                    </details>
                </li>
            </ul>

              <span class="separator"></span>
              <h3>어떤 방법을 골라야 할까?</h3>
              <p>"올바른" 방법은 프로젝트의 요구 사항에 따라 결정된다. 만약 큰 프로젝트를 한다면 규모가 있는 코드를 짜기 위해 CSS 속성으로 갈 수 있다.
              반면에 기존 브라우저에 보태는 정도면 다른 방법으로 접근할 수 있다.</p>
              <p>꼭 한 가지 방법만 쓸 수 있다는 것도 아니다. 때로는 여러 방법들을 혼합해서 쓰는 것이 효과적일 수도 있고, 우리가 논한 것 보다 다른 가능한 방법들이 더 많을 수도 있다.</p>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part2">
            <h2>운영체제 단계에서 다크 모드</h2>
            <p>지금까지 라이트 모드와 다크 모드를 전환하는 버튼을 사용했지만 사용자의 운영체제가 알아서 이러한 작업을 수행하게 할 수도 있다.
             예를 들면, 많은 운영체제들이 시스템 환경설정에서 바로 라이트 모드나 다크 모드를 선택할 수 있게 되어있다.</p>
            <img src="../imgs/capture_general.png" alt="MacOS System Preferences" width="900">
            <span class="img_info">"일반" MacOS Mojave 시스템 환경설정</span>
            <ul class="sample">
                <li>
                    <h4>Pure CSS</h4>
                    <p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="css-tricks" data-slug-hash="mdVrQXV" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Prefers Color Scheme: Demo Use Case">
                      <span>See the Pen <a href="https://codepen.io/team/css-tricks/pen/mdVrQXV">
                      Prefers Color Scheme: Demo Use Case</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks">@css-tricks</a>)
                      on <a href="https://codepen.io">CodePen</a>.</span>
                    </p>
                    <br>
                    <details>
                        <summary>Details</summary>
                        <p>다행히 CSS는 사용자의 시스템 색상 설정을 감지하는 데 사용할 수 있는 <code class="highlight">prefers-color-scheme</code> 미디어 쿼리가 있다. 이는 세가지 값을 가질 수 있다: 설정 없음, 라이트, 다크.
                        자세한건 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme">MDN</a>에서 알아보자.</p>
                        <pre class="css">
                            <code>
@media (prefers-color-scheme: dark) {
  /* Dark theme styles go here */
}
 
@media (prefers-color-scheme: light) {
  /* Light theme styles go here */
}
                            </code>
                        </pre>
                        <p>미디어 쿼리안에 다크 테마 스타일을 넣으면 된다.</p>
                        <pre class="css">
                            <code>
@media (prefers-color-scheme: dark) {
  body {
    color: #eee;
    background: #121212;
  }
 
  a {
    color: #809fff;
  }
}
                            </code>
                        </pre>
                        <p>이제, 만약 사용자가 시스템 설정에서 다크 모드를 켰다면, 다크 모드 스타일을 기본으로 받을 것이다. 사용자 모드를 정하기 위해 JavaScript나 server-side 스크립트에 의존할 필요가 없다. 버튼도 더 이상 필요없다.</p>
                    </details>
                </li>
                <li>
                    <h4>JavaScript</h4>
                    <p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js" data-user="css-tricks" data-slug-hash="NWxREYg" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Prefers Color Scheme: Using JS to detect">
                      <span>See the Pen <a href="https://codepen.io/team/css-tricks/pen/NWxREYg">
                      Prefers Color Scheme: Using JS to detect</a> by CSS-Tricks (<a href="https://codepen.io/css-tricks">@css-tricks</a>)
                      on <a href="https://codepen.io">CodePen</a>.</span>
                    </p>
                    <br>
                    <details>
                        <summary>Details</summary>
                        <p>사용자 색상 선호를 감지하기위헤 JavaScript로 전환할 수도 있다. 이건 처음에 작업했던 방법과 매우 유사하다, 다만 이건 사용자 설정을 감지하기 위해 <code class="highlight">matchedMedia()</code> 만 사용한다.</p>
                        <pre class="js">
                            <code>
const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');nnif (prefersDarkScheme.matches) {n  document.body.classList.add('dark-theme');n} else {n  document.body.classList.remove('dark-theme');n}
                            </code>
                        </pre>
                        <p>JavaScript를 썼을때 단점이 있다: CSS 후에 자바스크립트가 실행돼서 라이트테마가 빠르게 깜빡일 수 있는데 이걸 버그로 오해할 수도 있다.</p>
                        <p>물론, 우리가 해본 두번째 방법 대신 스타일시트를 바꿀 수 있지만 이번에는 두 스타일시트를 연결하고 미디어쿼리를 사용하여 어떤 스타일이 적용되는지 확인해보자.</p>
                    </details>
                </li>
                <li>
                    <h4>OS 설정 오버라이딩 하기</h4>
                    <p>사용자의 시스템 전반에 걸친 색상 설정을 처리하는 방법을 살펴봤다. <strong>하지만 만약 사용자가 사이트에 대해 시스템 설정을 재정의 하고 싶다면?</strong>
                    사용자가 OS에 대해 다크 모드를 선호한다 해서 웹사이트에 대해서도 항상 그럴 거라는 뜻은 아니다. 그래서 시스템 설정에도 불구하고, 수동으로 다크 모드를 재정의하는 방법을 제공하는 것은 좋은 아이디어다.</p>
                    <details>
                        <summary>View Code</summary>
                        <p>CSS 커스텀 속성을 사용해서 적용 방법을 보자. 이전에 했던 것 처럼 두 테마에대헤 사용자 속성을 정의하는건데, 다크 스타일을 <code class="highlight">prefers-color-scheme</code> 미디어 쿼리로 감싸고,
                        <code class="highlight">.light-theme</code> 클래스를 내부에 정의해서 사용자가 두 모드 사이를 전환하려는 경우 다크 모드 속성을 재정의하는데 사용할 수 있다.</p>
                        <pre class="css">
                            <code>
/* Default colors */
body {
  --text-color: #222;
  --bkg-color: #fff;
}
/* Dark theme colors */
body.dark-theme {
  --text-color: #eee;
  --bkg-color: #121212;
}

/* Styles for users who prefer dark mode at the OS level */
@media (prefers-color-scheme: dark) {
  /* defaults to dark theme */
  body {
    --text-color: #eee;
    --bkg-color: #121212;
  }
  /* Override dark mode with light mode styles if the user decides to swap */
  body.light-theme {
    --text-color: #222;
    --bkg-color: #fff;
  }
}
                            </code>
                        </pre>
                        <p>이제 우리의 믿음직한 버튼으로 돌아가 라이트테마와 다크 테마를 전환할 수 있다. <strong>이렇게 하면 기본적으로 OS 색상 설정을 존중하면서 사용자가 수동으로 테마를 바꿀 수 있다.</strong></p>
                        <pre class="js">
                            <code>
// Listen for a click on the button
btn.addEventListener("click", function() {
  // If the OS is set to dark mode...
  if (prefersDarkScheme.matches) {
    // ...then apply the .light-theme class to override those styles
    document.body.classList.toggle("light-theme");
    // Otherwise...
  } else {
    // ...apply the .dark-theme class to override the default light styles
    document.body.classList.toggle("dark-theme");
  }
});
                            </code>
                        </pre>
                        <p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="result" data-user="adhuham" data-slug-hash="GRJxpQr" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Prefers Color Scheme: Wrap Up">
                          <span>See the Pen <a href="https://codepen.io/adhuham/pen/GRJxpQr">
                          Prefers Color Scheme: Wrap Up</a> by Mohamed Adhuham (<a href="https://codepen.io/adhuham">@adhuham</a>)
                          on <a href="https://codepen.io">CodePen</a>.</span>
                        </p>
                    </details>
                </li>
                <li>
                    <h4>Browser Support</h4>
                    <p><code class="highlight">prefers-color-scheme</code> 미디어 쿼리 기능은 주요 브라우저, Chrome 76+, Firefox 67+, Chrome Android 76+, Safari 12.5+ (13+ on iOS), 그리고 Samsung Internet Browser에서 지원되고 IE는 지원하지 않는다.</p>
                    <p>이건 유망한 양의 지원이다. "Can I Use"는 80.85%의 사용자 범위를 측정한다.</p>
                    <p>현재 다크 모드를 지원하는 운영체제에는 MacOS (Mojave or later), iOS (13.0+), Windows (10+), 그리고 Android (10+)가 있다.</p>
                </li>
            </ul>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part3">
            <h2>사용자 설정 저장</h2>
            <p>지금까지 OS 환경설정 또는 버튼 클릭에 따라 테마를 변경하는 것을 살펴봤다. 이것도 훌륭하지만, 이는 방문자가 다른 페이지를 방문하거나 페이지를
            새로고침 했을 때는 적용되지 않는다.</p>
            <p>사용자의 선택을 저장하여 사이트 전체나 이후 방문했을 때 일관되게 적용되게 해야 한다. 이를 위해 localStorage에 저장하여 사용자의 선택대로 테마를 변경할 수 있다.
            이는 쿠키에도 적합한 작업이다.</p>
            <p>자 두 가지 방법 모두 살펴보자.</p>
            <ul class="sample">
                <li>
                    <h4>localStorage 사용하기</h4>
                    <p>토글하면 선택된 테마를 localStorage에 저장하는 스크립트가 있다. 즉, 페이지가 다시 로드될 때, 스크립트는 localStorage에서 선택된 것을 적용한다.
                    JavaScript는 종종 CSS 이후에 실행되므로 이 방식은 <strong>"flash of incorrect theme(FOIT)"</strong>가 발생하기 쉽다.</p>
                    <details>
                        <summary>View Code</summary>
                        <pre class="js">
                            <code>
// Select the button
const btn = document.querySelector(".btn-toggle");
// Select the theme preference from localStorage
const currentTheme = localStorage.getItem("theme");
 
// If the current theme in localStorage is "dark"...
if (currentTheme == "dark") {
  // ...then use the .dark-theme class
  document.body.classList.add("dark-theme");
}
 
// Listen for a click on the button
btn.addEventListener("click", function() {
  // Toggle the .dark-theme class on each click
  document.body.classList.toggle("dark-theme");

  // Let's say the theme is equal to light
  let theme = "light";
  // If the body contains the .dark-theme class...
  if (document.body.classList.contains("dark-theme")) {
    // ...then let's make the theme dark
    theme = "dark";
  }
  // Then save the choice in localStorage
  localStorage.setItem("theme", theme);
});
                           </code>
                        </pre>
                        <p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="result" data-user="adhuham" data-slug-hash="YzXayaq" style="height:300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Dark Mode: Persisting User's Choice">
                          <span>See the Pen <a href="https://codepen.io/adhuham/pen/YzXayaq">
                          Dark Mode: Persisting User's Choice</a> by Mohamed Adhuham (<a href="https://codepen.io/adhuham">@adhuham</a>)
                          on <a href="https://codepen.io">CodePen</a>.</span>
                        </p>
                    </details>
                </li>
                <li>
                    <h4>PHP와 쿠키 사용하기</h4>
                    <p>FLIC를 피하기 위해, PHP와 같은 server-side 스크립트를 쓸 수 있다. 사용자의 테마 설정을 localStorage에 저장하는 대신에,
                    JavaScript로부터 쿠키를 만들고 거기에 저장하는 것이다. 하지만 이것은 이미 server-side 언어로 작업할 때만 가능하다.</p>
                    <details>
                        <summary>View Code</summary>
                        <pre class="js">
                            <code>
// Select the button
const btn = document.querySelector(".btn-toggle");
 
// Listen for a click on the button
btn.addEventListener("click", function() {
  // Toggle the .dark-theme class on the body
  document.body.classList.toggle("dark-theme");

  // Let's say the theme is equal to light
  let theme = "light";
  // If the body contains the .dark-theme class...
  if (document.body.classList.contains("dark-theme")) {
    // ...then let's make the theme dark
    theme = "dark";
  }
  // Then save the choice in a cookie
  document.cookie = "theme=" + theme;
});
                            </code>
                        </pre>
                        <p>우리는 이제 쿠키의 존재와 적절한 클래스가 <code class="highlight">&lt;body&gt;</code>적용되어 적절한 테마가 로드되는지 확인할 수 있다.</p>
                        <pre class="php">
                            <code>
&lt;?php
$themeClass = '';
if (!empty($_COOKIE['theme']) && $_COOKIE['theme'] == 'dark') {
  $themeClass = 'dark-theme';
}
?&gt;
 
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;!-- etc. --&gt;
&lt;body class="&lt;?php echo $themeClass; ?&gt;"&gt;
&lt;!-- etc. --&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                        </pre>
                        <p>아래는 분리된 스타일시트를 사용하는 방식이다.</p>
                        <pre class="php">
                            <code>
&lt;?php
$themeStyleSheet = 'light-theme.css';
if (!empty($_COOKIE['theme']) && $_COOKIE['theme'] == 'dark') {
  $themeStyleSheet = 'dark-theme.css';
}
?&gt;
 
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;!-- etc. --&gt;
  &lt;link href="&lt;?php echo $themeStyleSheet; ?&gt;" rel="stylesheet" id="theme-link"&gt;
&lt;/head&gt;
&lt;!-- etc. --&gt;
                            </code>
                        </pre>
                        <p>만약 사에트에 사용자 계정이 있다면 - 로그인/프로필 관리 등이 위치한 부분은 - 테마 설정을 저장하기에 좋은 공간이다. 계정 상세설정 쪽으로 데이터를 보내고 저장시키면 된다.
                        그리고 사용자가 로그인했을때, 데이터베이스에서 테마를 가져오고 PHP(또는 다른 server-side script)를 사용해 페이지ㅣ에 적용한다.</p>
                        <p>더 다양한 방법이 존재한다. 이 예시는 사용자의 테마 설정을 데이터베이스에서 가져오고 로그인 할 때 세션에 저장하는 방법이다.</p>
                        <pre class="php">
                            <code>
&lt;?php
// Login action
if (!empty($_POST['login'])) {
  // etc.
 
  // If the uuser is authenticated...
  if ($loginSuccess) {
    // ... save their theme preference to a session variable
    $_SESSION['user_theme'] = $userData['theme'];
  }
}
 
// Pick the session variable first if it's set; otherwise pick the cookie
$themeChoice = $_SESSION['user_theme'] ?? $_COOKIE['theme'] ?? null;
$themeClass = '';
if ($themeChoice == 'dark') {
  $themeClass = 'dark-theme';
}
?&gt;
 
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;!-- etc. --&gt;
&lt;body class="&lt;?php echo $themeClass; ?&gt;"&gt;
&lt;!-- etc. --&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                        </pre>
                        <p>PHP의 <a href="">null coalesce operator</a>를 사용하여 테마 설정을 어디서 선택할지 정할때 사용한다(세션 또는 쿠키에서). 만약 로그인이 되어있다면,
                        쿠키대신 세션 값이 사용되고 로그인 되어있지 않거나 로그아웃을 했을 경우엔 쿠키가 사용된다.</p>
                    </details>
                </li>
            </ul>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part4">
            <h2>UA 스타일 다루기</h2>
            <p>색상 배색 설정에 관한 브라우저 UA 스타일시트와 어떤 색상 구성들이 페이지에 지원되는지 알리려면 <code class="highlight">color-scheme</code> meta 태그를 사용할 수 있다.</p>
            <p>예를 들어 페이지가 라이트 테마와 다크 테마를 모두 지원해야 한다 치면, 메타 태그에 두 테마 공백으로 구분해서 모두 meta 태그에 넣을 수 있다.
            만약 라이트 테마만 지원하면, "light" 만 값에 넣으면 된다. 이 부분은 원본 글 <a href="https://github.com/w3c/csswg-drafts/issues/3299" target="_blank">CSSWG GitHub issue</a>에서 자세히 확인할 수 있다.</p>
            <div class="sample">
                <pre>
                    <code>
&lt;meta name="color-scheme" content="dark light"&gt;
                    </code>
                </pre>
            </div>
            <p>meta 태그가 추가되었을 때, 브라우저는 페이지의 UA 요소(ex, <code class="highlight">&lt;button&gt;</code>)를 렌더링 할 때 사용자의 색상 배색 설정을 고려한다.
            이는 사용자의 기본 설정에 따라 배경, 양식, 맞춤법 검사(다른 UA 제어 스타일)에 대한 색상을 렌더링 한다.</p>
            <img width="2408" src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/06/jwtAqLmj.jpeg?fit=1024%2C341&amp;ssl=1" alt="">
            <p>테마들이 대부분 수동으로 스타일이 지정되지만(UA 스타일을 덮어서), 지원되는 테마에 대해 브라우저는 FOIT(Flash of invisible text)가 발생하지 않게 도와주기도 한다.
            이는 HTML은 렌더 되었는데 CSS는 아직 로딩 중 일 때 해당된다.</p>
            <p>아래 CSS처럼 세팅할 수도 있다.</p>
            <div class="sample">
                <pre class="css">
                    <code>
:root {
  color-scheme: light dark; /* both supported */
}
                    </code>
                </pre>
            </div>
            <p>작성 당시, <code class="highlight">color-scheme</code> 속성을 Safari와 Chrome은 지원하는데 나머지는 지원하지 않았다.</p>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part5">
            <h2>응용하기</h2>
            <p>자 이제, 지금까지 다룬 것들을 다 합쳐서 데모를 만들어 보자:</p>
            <ol class="numbering">
                <li>시스템 환경설정에 따라 자동으로 테마를 로드해본다.</li>
                <li>시스템 환경설정을 수동으로 재정의하게 한다.</li>
                <li>페이지 새로고침할 때 선호하는 테마가 유지되게 한다.</li>
            </ol>
            <p class="codepen" data-height="300" data-theme-id="dark" data-default-tab="js,result" data-user="adhuham" data-slug-hash="BaNroxd" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Dark Mode: Combining Everything">
              <span>See the Pen <a href="https://codepen.io/adhuham/pen/BaNroxd">
              Dark Mode: Combining Everything</a> by Mohamed Adhuham (<a href="https://codepen.io/adhuham">@adhuham</a>)
              on <a href="https://codepen.io">CodePen</a>.</span>
            </p>
            <ul class="sample">
                <li>
                    <h4>JavaScript & Local Storage</h4>
                    <details>
                        <summary>View Code</summary>
                        <pre class="js">
                            <code>
                                // Select the button
const btn = document.querySelector(".btn-toggle");
// Check for dark mode preference at the OS level
const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
 
// Get the user's theme preference from local storage, if it's available
const currentTheme = localStorage.getItem("theme");
// If the user's preference in localStorage is dark...
if (currentTheme == "dark") {
  // ...let's toggle the .dark-theme class on the body
  document.body.classList.toggle("dark-mode");
// Otherwise, if the user's preference in localStorage is light...
} else if (currentTheme == "light") {
  // ...let's toggle the .light-theme class on the body
  document.body.classList.toggle("light-mode");
}
 
// Listen for a click on the button
btn.addEventListener("click", function() {
  // If the user's OS setting is dark and matches our .dark-mode class...
  if (prefersDarkScheme.matches) {
    // ...then toggle the light mode class
    document.body.classList.toggle("light-mode");
    // ...but use .dark-mode if the .light-mode class is already on the body,
    var theme = document.body.classList.contains("light-mode") ? "light" : "dark";
  } else {
    // Otherwise, let's do the same thing, but for .dark-mode
    document.body.classList.toggle("dark-mode");
    var theme = document.body.classList.contains("dark-mode") ? "dark" : "light";
  }
  // Finally, let's save the current preference to localStorage to keep using it
  localStorage.setItem("theme", theme);
});
                            </code>
                        </pre>
                    </details>
                </li>
                <li>
                    <h4>PHP & Cookies</h4>
                    <details>
                        <summary>View Code</summary>
                        <pre class="php">
                            <code>
&lt;?php
$themeClass = '';
if (!empty($_COOKIE['theme'])) {
  if ($_COOKIE['theme'] == 'dark') {
    $themeClass = 'dark-theme';
  } else if ($_COOKIE['theme'] == 'light') {
    $themeClass = 'light-theme';
  }
}
?&gt;
 
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;!-- etc. --&gt;
&lt;body class="&lt;?php echo $themeClass; ?&gt;"&gt;
&lt;!-- etc. --&gt;
&lt;script&gt;
  const btn = document.querySelector(".btn-toggle");
  const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");

  btn.addEventListener("click", function() {
    if (prefersDarkScheme.matches) {
      document.body.classList.toggle("light-mode");
      var theme = document.body.classList.contains("light-mode") ? "light" : "dark";
    } else {
      document.body.classList.toggle("dark-mode");
      var theme = document.body.classList.contains("dark-mode") ? "dark" : "light";
    }
    document.cookie = "theme=" + theme;
  });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
                            </code>
                        </pre>
                    </details>
                </li>
            </ul>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part6">
            <h2>디자인 고려사항</h2>
            <p>다크 모드를 구현하는 것보다 디자인하는 게 더 쉽다는 말을 종종 듣는다.
            판단은 보류하고 다크 테마 디자인을 할 때 고려해야 할 사항들을 살펴보자.</p>
            <p>라이트 테마와 다크 테마를 전환하는 기본적인 것은 이미 알고 있을 것이다. 그러나 미묘하고 주의가 필요한 UI 요소와 기능들이 몇 가지 더 있다.</p>
            <h3>이미지</h3>
            <p>어두운 배경에서는 이미지의 밝기와 대조를 조금 줄여 눈을 편하게 하는 것도 좋은 방법 중 하나다.
            엄청 어두운 배경에 엄청 밝은 이미지는 눈에 거슬릴 수 있고, 희미한 이미지는 무거운 대비를 줄일 수 있다.</p>
            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/image-optimized-1.png" alt="before">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/image-normal-1.png" alt="after">
                    </div>
                </div>
            </figure>

            <p>CSS <code class="highlight">filter()</code>는 이 현상을 해결할 수 있다.</p>
            <div class="sample">
                <pre class="css">
                    <code>
/* Apply the filter directly on the body tag */
body.dark-theme img {
  filter: brightness(.8) contrast(1.2);
}
 
/* Or apply it via media query */
@media (prefers-color-scheme: dark) {
  img {
    filter: brightness(.8) contrast(1.2);
  }
}
                    </code>
                </pre>
            </div>
            <p>다른 버전들의 이미지를 로드하기 위해 <code class="highlight">&lt;picture&gt;</code> 요소를 마크업에 바로 적용할 수도 있다.</p>
            <div class="sample">
                <pre>
                    <code>
&lt;picture&gt;
  &lt;!-- Use this image if the user's OS setting is light or unset --&gt;
  &lt;source srcset="photo-light.png" media="(prefers-color-scheme: light) or (prefers-color-scheme: no-preference)"&gt;
  &lt;!-- Use this image if the user's OS setting is dark --&gt;
  &lt;source srcset="photo-dark.png" media="(prefers-color-scheme: dark)"&gt;
&lt;/picture&gt;
                    </code>
                </pre>
            </div>
            <p>여기서 단점은 (CSS사용할 때) 하나를 처리하는데 두 개의 파일을 제공해야 하는 것이다. 또한, 사이트의 테마를 전환하는 사용자를 위해 완벽하게 처리하지는 않는 것이다.</p>
            <h3>그림자</h3>
            <p>다크 모드에서 그림자는 좀 까다롭다. 단순하게 다크 모드 그림자를 밝은 색상으로 반전시키면, 어두운 배경에 밝은 색의 그림자가 있는 기이한 현상을 보게 되는데.. 딱히 보기 좋진 않다.</p>
            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/white-shadow-fixed-2.png" alt="before">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/white-shadow-2.png" alt="after">
                    </div>
                </div>
            </figure>

            <p>다크 모드에 어두운 그림자가 가능하지만, 그렇다면 그림자를 확연히 구분할 수 있을 만큼 배경색이 충분히 밝아야 한다. (ex. 어두운 회색)</p>
            <blockquote class="twitter-tweet" style="margin-bottom:30px">
                <p lang="en" dir="ltr">🔥 When implementing dark mode, don’t throw away the visual cues in the light version by naively inverting the color scheme.<br><br>Close elements should still be lighter and distant elements should still be darker – even in a dark UI.
                    <a href="https://t.co/RNxgIppDmn">pic.twitter.com/RNxgIppDmn</a>
                </p>&mdash; Steve Schoger (@steveschoger) <a href="https://twitter.com/steveschoger/status/1151160261170126850?ref_src=twsrc%5Etfw">July 16, 2019</a></blockquote>
                <script async src="https://platform.twitter.com/widgets.js"></script>
            <p>깊이가 낮은 영역은 높은 opacity로 가지고 있듯이 깊이감을 전달하기 위해서 opacity를 사용하면 된다. 즉, 배경에 가까운 요소보다 고도가 더 높은 요소의 opacity가 낮아야 한다.</p>
            <img width="2408" src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/06/depth-4.png?fit=1024%2C375&ssl=1" alt="">
            <span class="img_info">Different shades of color create different perceptions of “depth”</span>

            <h3>타이포그래피</h3>
            <p>타이포그래피도 이미지와 마찬가지로 대조의 균형을 맞춰야 한다. 너무 무거운 폰트를 쓰면 텍스트들이 왕왕거려서 화면을 보기 싫을 것이고, 너무 가벼운 폰트는 화면 가까이서 보게 돼서 눈이 더 피로할 것이다.</p>
            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/typo-thick-3.png" alt="">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/typo-thin-4.png" alt="">
                    </div>
                </div>
            </figure>

            <p>균형은 그 중간 어딘가에 있다. 로빈은 약간의 CSS로 가독성에 큰 차이를 주는 것에 대해 서술했다. <a href="https://css-tricks.com/dark-mode-and-variable-fonts/">(Dark mode and variable fonts)</a></p>

            <h3>아이콘</h3>
            <p>아이콘은 텍스트와 이미지 사이의 교차지점이라 좀 까다롭다. SVG 아이콘으로 작업한다면 fill로 색상을 바꿀 수 있고, 폰트 아이콘을 사용한다면 대신 color 속성으로 바꿀 수 있다.</p>
            <div class="sample">
                <pre class="css">
                    <code>
/* SVG icon */
body.dark-theme svg.icon path {
  fill: #efefef;
}
/* Font icon (using Font Awesome as an example) */
body.dark-theme .fa {
  color: #efefef;
}
                    </code>
                </pre>
            </div>
            <p>텍스트에 적용되는 일반적인 고려 사항들은 폰트에도 동일하게 적용된다. 완전 흰색과 두꺼운 아웃라인을 사용하지 않는 것을 예시로 들 수 있다.</p>

            <h3>Colors</h3>
            <p>순수 흰색 텍스트와 순수 검은색 배경은 보기에 거슬릴 것이다. 여기서 트릭은 옅은 흰색 폰트와 옅은 검은색의 배경을 사용하는 것이다.
                <a href="#">Material Design Guidelines</a>에서는 <code class="highlight">#121212</code> 색상을 배경색으로 추천했다.
            </p>
            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/bkg-fixed-3.png" alt="before">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/bkg-3.png" alt="after">

                    </div>
                </div>
            </figure>

            <h3>Color Palettes</h3>
            <p>텍스트와 이미지에 미색의 흰색/검은색을 사용했을 때의 차이점을 봤으니, 시야를 좀 넓혀서 풀 컬러 팔레트를 만드는 팁을 알아보자.</p>
            <p>대부분 <strong>"대비"</strong> 하나로 요약된다. 그렇기 때문에 색상을 정하기 전에 첫 번째 팁은 대비 검사기를 통해 색상 비율이
            적절한지 확인하는 것이다. WCAG의 가이드라인에 따르면 AA 등급은 비율이 4.5:1이다.<br>
            <a href="#">(Understanding Web Accessibility Color Contrast Guidelines and Ratios)</a></p>

            <p>즉, 다크 모드 디자인으로 작업을 할 때 채도가 낮은 색상들은 우리의 친구들이다. 채도가 낮은 색상들은 지나치게 밝은 이미지들을 방지하고,
            효과적인 명암비를 만들 수 있는 여유를 제공한다.</p>

            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/desaturate-fixed-4.png" alt="before">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/desaturate-3.png" alt="after">

                    </div>
                </div>
            </figure>

            <p>다음, 강조 색상들은 확장/증대의 의미로 여겨진다는 점을 기억해야 한다. 강조 색상들은 대게 다크 모드의 배경색보다 밝기 때문에 원색이나
            큰 영역의 배경색으로는 밝은 이미지나 두꺼운 흰 텍스트를 보는 것처럼 눈에 거슬리고 무리가 간다.</p>

            <figure class="compare_wrap">
                <div class="js-img-compare">
                    <div style="display: none;">
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/color-blob-fixed-1.png" alt="before">
                    </div>
                    <div>
                        <img src="https://css-tricks.com/wp-content/uploads/2020/06/color-blob-2.png" alt="after">

                    </div>
                </div>
            </figure>

            <p>만약 대비가 계산하려는 것이라면, 다크 모드는 검정과 회색뿐만 아니라는 것을 기억해야 한다. 어두운 파란색의 배경에 연한 노란색 텍스트,
            또는 어두운 갈색과 황갈색은 어떤가? 전체 (그리고 점점 늘어나는) 색상 스펙트럼에서 우리는 창의력을 발휘해 더 끌어낼 수 있다.
            <a href="https://css-tricks.com/the-expanding-gamut-of-color-on-the-web/">(The Expanding Gamut of Color on the Web)</a></p>

            <p>완전 검정색이 아닌 어두운 색상 예시들이 있다:</p>
            <ul class="colors_ex">
                <li><p>#232B32</p></li><li><p>#152028</p></li><li><p>#202945</p></li>
            </ul>

            <p><a href="#">Material Design’s guidelines on dark mode</a> 는 다크 모드 디자인 모범 예시들과 유용한 정보들이 있다.
            알아둬야 할 팁들이 더 있으니 읽어보는 것을 추천한다.</p>
        </div>
        <span class="separator"></span>
        <div class="parts" id="part7">
            <h2>다크 모드 활용 예시</h2>
            <p>YouTube는 CSS 변수 기술을 사용했다. 그들은 모든 색상들을 html 선택자 아래 변수에 지정하고 다크 모드 색상은
                <code class="highlight">html:not(.style-scope)[dark]</code>로 지정했다.
                다크 모드가 활성화되면, <code class="highlight">&lt;html&gt;</code> 태그에 <code class="highlight">dark="true"</code>속성을 추가한다.
                원래 HTML 변수의 정의를 유투브가 재정의한 것이다.</p>
                <img loading="lazy" src="https://css-tricks.com/wp-content/uploads/2020/06/b0FBHzyc-1-e1593210129104-1024x991.png" alt="YouTube theme">
                <span class="img_info">YouTube adds dark=true attribute to the &lt;html&gt; when it switches to the dark mode.</span>

            <p>실제로, CSS 커스텀은 가장 인기 있는 방식으로 보인다. Dropbx Paper, Slack, Facebook에서도 이 방식을 사용한다.</p>

            <p>Simplenote는 class 교체 방식을 사용한다. 모든 라이트 테마 스타일은 <code class="highlight">.theme-light</code> 클래스의 자식으로 넣고,
            다크 테마 스타일은 <code class="highlight">.theme-dark</code> 클래스 밑으로 넣는 것이다. 테마가 교체될 때, 적합한 클래스가 <code class="highlight">&lt;body&gt;</code> 태그에 적용된다.</p>
            <img loading="lazy" src="https://css-tricks.com/wp-content/uploads/2020/06/UsbhAk5g-1-e1593210246404-1024x1003.png" alt="Simplenote theme">
            <span class="img_info">Simplenote uses two classes: .light-theme and .dark-theme to style the themes.</span>

            <p>Twitter는 조금 더 가서 "Default," "Dim," "Lights out" 중에 테마를 고를 수 있게 제공한다. "Dim" 테마는 다크블루 색상을 배경으로 쓴다. 완전 검은색인 "Lights out" 테마와 비교가 된다.</p>
            <img loading="lazy" src="https://css-tricks.com/wp-content/uploads/2020/06/0cDi_Rnw-1024x441.png" alt="Twiiter theme" >
            <span class="img_info">트위터는 세가지 테마를 제공하다.</span>
        </div>
    </div>
</div>

<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
<script async src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
<script async src="../js/jquery-latest.min.js"></script>
<script async src="../js/jquery.images-compare.js"></script>
<script>
    $(function () {
        var imagesCompareElement = $('.js-img-compare').imagesCompare();
        var imagesCompare = imagesCompareElement.data('imagesCompare');
        var events = imagesCompare.events();

        // CHANGE EVENT TESTS AND
        // GETTER SETTER TESTS
        function testElementChangeEvent(event) {
            QUnit.test("test change event listener", function (assert) {
                assert.equal(event.ratio, 1, 'Change event received and value equal 1');
            });
        }

        function testChangeEvent(event) {
            QUnit.test("test change event listener", function (assert) {
                assert.equal(event.ratio, 0, 'Change event received and value equal 0');
            });
        }

        // Async tests
        QUnit.test("Change event tests and getter setter tests", function (assert) {
            var numCalls = 3;
            assert.expect(numCalls);
            var done = assert.async(numCalls);

            // change value 1 and listen to element
            setTimeout(function () {
                imagesCompareElement.on(events.changed, testElementChangeEvent);
                imagesCompare.setValue(1);
                assert.equal(imagesCompare.getValue(), 1, "test get and set value from outside : Changed value success (1)");
                done();
            }, 60);

            // change value 0 and listen to "data" object
            setTimeout(function () {
                imagesCompareElement.off(events.changed, testElementChangeEvent);
                imagesCompare.on(events.changed, testChangeEvent);
                imagesCompare.setValue(0);
                assert.equal(imagesCompare.getValue(), 0, "test get and set value from outside : Changed value success (0)");
                done();
            }, 120);

            setTimeout(function () {
                assert.ok(true, 'test get and set value from outside and event completed');
                imagesCompare.off(events.changed, testChangeEvent);
                done();
            }, 180);
        });

        // RESIZE EVENT TEST
        function testResizeEvent(event) {
            QUnit.test("test resize event", function (assert) {
                assert.ok(true, 'Resize event received');
            });
        }

        imagesCompareElement.on(events.resized, testResizeEvent);
        $(window).trigger('resize');
        imagesCompareElement.off(events.resized, testResizeEvent);

        imagesCompare.on(events.resized, testResizeEvent);
        $(window).trigger('resize');
        imagesCompare.off(events.resized, testResizeEvent);
    });
</script>
<script>
    hljs.initHighlightingOnLoad();
</script>
<script>
    initComparisons();
</script>
</body>
</html>
